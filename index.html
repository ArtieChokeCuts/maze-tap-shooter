      tunnelMesh.position.z = -150; 
      scene.add(tunnelMesh);

      const light1 = new THREE.PointLight(0x0066ff, 2, 100);
      light1.position.set(15, 5, -50); scene.add(light1);
      const light2 = new THREE.PointLight(0xff6600, 2, 100);
      light2.position.set(-15, 5, -80); scene.add(light2);

      animateLights = () => {
        const time = Date.now() * 0.001;
        light1.position.x = 15 * Math.sin(time * 0.5);
        light1.position.y = 5 * Math.cos(time * 0.3);
        light2.position.x = -15 * Math.sin(time * 0.4);
        light2.position.y = 5 * Math.cos(time * 0.2);
      };
    }

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.y = 1.6;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // HUD Canvas
    const hudCanvas = document.getElementById('hud');
    ctx = hudCanvas.getContext('2d');
    hudCanvas.width = window.innerWidth;
    hudCanvas.height = window.innerHeight;

    // Create game elements
    createTunnel();
    
    // Initialize game state
    window.score = 0;
    window.combo = 0;
    window.comboTimer = 0;
    window.level = 1;
    window.health = 100;
    window.ammo = 30;
    window.maxAmmo = 30;
    window.reloading = false;
    window.enemiesSpawned = 0;
    window.enemiesToNextLevel = 10;
    window.spawnRate = 2000;

    // Start game loop
    gameRunningGlobal = true;
    animate();

    // Show instructions
    document.getElementById('instructions').style.display = 'block';

    // Start spawning targets
    setTimeout(spawnTargets, 1000);
  }

  function spawnTargets() {
    if (!gameRunningGlobal) return;

    // Spawn enemy
    createTarget(true);
    
    // Occasionally spawn powerup
    if (Math.random() < 0.2) {
      createTarget(false, Math.random() < 0.5 ? 'reload_pack' : 'health_pack');
    }

    setTimeout(spawnTargets, window.spawnRate);
  }

  function animate() {
    if (!gameRunningGlobal) return;

    requestAnimationFrame(animate);
    animateLights();

    // Update targets
    targets.forEach(target => {
      if (!target.userData.hit) {
        target.position.z += 0.1 + (window.level * 0.01);
        
        // Remove if passed player
        if (target.position.z > 5) {
          scene.remove(target);
          targets = targets.filter(t => t !== target);
        }
      }
    });

    // Update explosions
    explosions.forEach(explosion => {
      explosion.particles.forEach(particle => {
        particle.position.add(particle.userData.velocity);
        particle.material.opacity -= 0.02;
      });
      explosion.timer--;
      
      if (explosion.timer <= 0) {
        explosion.particles.forEach(particle => scene.remove(particle));
        explosions = explosions.filter(e => e !== explosion);
      }
    });

    renderer.render(scene, camera);
  }

  // Shooting mechanics
  function shoot() {
    if (window.reloading) return;
    
    if (window.ammo <= 0) {
      reload();
      return;
    }
    
    window.ammo--;
    shootSound.currentTime = 0;
    shootSound.play().catch(e => console.warn("Shoot sound error:", e));
    
    // Check for hits
    targets.forEach(target => {
      if (!target.userData.hit && target.position.z > -5 && target.position.z < 5) {
        target.userData.hit = true;
        createExplosion(target.position.x, target.position.y, target.position.z);
        
        if (target.userData.type === 'enemy') {
          window.score += 100 * (1 + (window.combo * 0.1));
          window.combo++;
          window.comboTimer = 100;
          window.enemiesSpawned++;
          
          // Show combo
          if (window.combo > 1) {
            const comboEl = document.getElementById('combo-display');
            comboEl.textContent = `COMBO x${window.combo}`;
            comboEl.style.opacity = 1;
            setTimeout(() => comboEl.style.opacity = 0, 1000);
          }
          
          // Check level up
          if (window.enemiesSpawned >= window.enemiesToNextLevel) {
            levelUp();
          }
        } else if (target.userData.type === 'powerup') {
          if (target.userData.subType === 'reload_pack') {
            window.ammo = window.maxAmmo;
            window.reloading = false;
          } else if (target.userData.subType === 'health_pack') {
            window.health = Math.min(100, window.health + 20);
          }
        }
        
        scene.remove(target);
        targets = targets.filter(t => t !== target);
      }
    });
  }

  function reload() {
    if (window.reloading) return;
    
    window.reloading = true;
    reloadSound.currentTime = 0;
    reloadSound.play().catch(e => console.warn("Reload sound error:", e));
    
    setTimeout(() => {
      window.ammo = window.maxAmmo;
      window.reloading = false;
    }, 2000);
  }

  function levelUp() {
    window.level++;
    window.enemiesSpawned = 0;
    window.enemiesToNextLevel = Math.floor(window.enemiesToNextLevel * 1.5);
    window.spawnRate = Math.max(500, window.spawnRate - 100);
    
    // Show level up effect
    const levelUpEl = document.getElementById('level-up');
    levelUpEl.textContent = `LEVEL ${window.level}`;
    levelUpEl.style.opacity = 1;
    levelUpEl.style.transform = 'translate(-50%, -50%) scale(1.5)';
    
    setTimeout(() => {
      levelUpEl.style.opacity = 0;
      levelUpEl.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 1500);
  }

  // Event listeners
  document.addEventListener('click', shoot);
  document.addEventListener('touchstart', shoot);
  
  document.getElementById('shoot-btn').addEventListener('touchstart', shoot);
  document.getElementById('left-btn').addEventListener('touchstart', () => {
    camera.position.x = Math.max(-6, camera.position.x - 3);
  });
  document.getElementById('right-btn').addEventListener('touchstart', () => {
    camera.position.x = Math.min(6, camera.position.x + 3);
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'a' || e.key === 'ArrowLeft') {
      camera.position.x = Math.max(-6, camera.position.x - 3);
    } else if (e.key === 'd' || e.key === 'ArrowRight') {
      camera.position.x = Math.min(6, camera.position.x + 3);
    } else if (e.key === ' ' || e.key === 'w' || e.key === 'ArrowUp') {
      shoot();
    }
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const hudCanvas = document.getElementById('hud');
    hudCanvas.width = window.innerWidth;
    hudCanvas.height = window.innerHeight;
  });
</script>
</body>
</html>