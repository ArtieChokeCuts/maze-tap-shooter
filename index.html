--- START OF FILE index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FPS Target Shooter with Explosions</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(to bottom, #0a0a2a, #1a1a4a);
      color: white;
      touch-action: none; 
      height: 100vh;
    }
    canvas { position: absolute; top: 0; left: 0; display: block; }
    canvas.webgl { z-index: 0; }
    canvas#hud { z-index: 1; pointer-events: none; }

    #loading, #start-screen, #game-over {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%; display: none;
      flex-direction: column; justify-content: center; align-items: center;
      z-index: 10;
      text-align: center;
      background: rgba(0, 0, 20, 0.95);
    }
    #loading { display: flex; } 
    
    #start-screen { display: none; } 
    h1, h2 { text-shadow: 0 0 15px currentColor; }
    #start-screen h1 { 
      font-size: 4rem; 
      color: #00ffcc; 
      margin-bottom:2rem;
      text-transform: uppercase;
      letter-spacing: 3px;
      background: linear-gradient(to right, #00ffcc, #0066ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #start-button, #restart-button {
      background: #0066ff; color: #fff; border:none;
      padding:15px 40px; font-size:1.5rem; border-radius:30px;
      cursor:pointer; letter-spacing:2px; text-transform:uppercase;
      box-shadow:0 0 15px #0066ff; transition:all .3s;
      font-family: 'Orbitron', sans-serif;
      margin: 20px 0;
      position: relative;
      overflow: hidden;
    }
    #start-button:hover, #restart-button:hover {
      transform: scale(1.1); box-shadow:0 0 25px #00ffcc;
      background: #00aaff;
    }
    #start-button:before, #restart-button:before {
      content: '';
      position: absolute;
      top: -10px; left: -10px;
      right: -10px; bottom: -10px;
      background: linear-gradient(45deg, #00ffcc, #0066ff, #00ffcc);
      z-index: -1;
      filter: blur(10px);
      opacity: 0.7;
      animation: border-pulse 3s infinite linear;
    }
    @keyframes border-pulse {
      0% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.05); opacity: 0.9; }
      100% { transform: scale(1); opacity: 0.7; }
    }

    #game-over { display:none; }
    #game-over h2 { 
      font-size:5rem; 
      color:#ff0066; 
      margin-bottom:2rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    #final-score { 
      font-size:2.5rem; 
      color:#00ffcc; 
      margin-bottom:3rem;
      text-shadow: 0 0 10px #00ffcc;
    }
    
    #instructions { 
      position:absolute; 
      bottom:20px; 
      color:#aaa; 
      font-size:1rem; 
      text-align:center; 
      width:100%; 
      max-width:500px; 
      padding:0 20px;
      line-height: 1.6;
      display: none; 
      z-index: 5; 
    }
    #instructions p { 
      margin-top: 0.5em; 
      background: rgba(0, 102, 255, 0.2);
      padding: 8px 15px;
      border-radius: 15px;
      border: 1px solid #00aaff;
    }
    
    #mobile-controls {
      position: fixed; bottom: 20px; width: 100%; display: none; 
      justify-content: space-between; padding: 0 20px; z-index: 2;
    }
    .mobile-btn {
      width: 80px; height: 80px; border-radius: 50%;
      background: rgba(0, 102, 255, 0.3); border: 2px solid #00ccff;
      color: white; display: flex; justify-content: center; align-items: center;
      font-size: 1.2rem; user-select: none; -webkit-user-select: none;
      touch-action: manipulation; box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
      transition: all 0.2s;
    }
    .mobile-btn:active { transform: scale(0.9); background: rgba(0, 204, 255, 0.5); }
    
    #level-up {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(1); 
      font-size: 3rem; color: #ff00ff; text-shadow: 0 0 20px #ff00ff;
      z-index: 20; opacity: 0; transition: opacity 0.5s, transform 0.5s;
      pointer-events: none; font-weight: bold; text-transform: uppercase;
    }
    
    #combo-display {
      position: fixed; top: 30%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5rem; color: #ff00ff; text-shadow: 0 0 15px #ff00ff;
      z-index: 20; opacity: 0; transition: opacity 0.3s, transform 0.3s;
      pointer-events: none; font-weight: bold;
    }

    #loading h1 { 
      color: #00ffcc; 
      text-shadow: 0 0 10px #00ffcc; 
      margin-bottom: 2rem;
      font-size: 2.5rem;
      animation: pulse 1.5s infinite alternate;
    }
    @keyframes pulse { 
      from { transform: scale(1); }
      to { transform: scale(1.05); text-shadow: 0 0 20px #00ffcc; }
    }
    .loading-content {
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; height: 100%; padding: 20px; text-align: center;
    }
    .progress-container { width: 80%; max-width: 400px; margin: 30px 0; }
    .progress-bar { 
      height: 20px; background: rgba(0, 40, 80, 0.5);
      border-radius: 10px; overflow: hidden; position: relative;
      box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
    }
    .progress { 
      height: 100%; background: linear-gradient(90deg, #0066ff, #00ffcc);
      width: 0%; transition: width 0.3s ease-out; position: relative; z-index: 1;
    }
    .progress-glow {
      position: absolute; top: 0; left: 0; height: 100%; width: 100%;
      background: linear-gradient(90deg, 
        rgba(0, 200, 255, 0.4) 0%, 
        rgba(0, 255, 200, 0.7) 50%, 
        rgba(0, 200, 255, 0.4) 100%);
      background-size: 200% 100%; animation: progress-glow 2s linear infinite;
      opacity: 0.7;
    }
    @keyframes progress-glow {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .loading-text {
      margin-top: 10px; color: #00aaff; font-size: 14px;
      text-shadow: 0 0 5px rgba(0, 170, 255, 0.5);
    }
    .hint {
      position: absolute; bottom: 30px; color: rgba(255, 255, 255, 0.6);
      font-size: 12px; animation: pulse 2s infinite; 
    }

    #orientation-warning {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); z-index: 1000; 
      display: none; justify-content: center; align-items: center;
      font-size: 1.8rem; color: #ff5555; text-align: center; padding: 20px;
    }
        
    @media (max-width: 768px) {
      #mobile-controls { display: flex; }
      #game-over h2 { font-size: 3rem; }
      #final-score { font-size: 2rem; }
      #level-up { font-size: 2rem; }
      #combo-display { font-size: 1.8rem; }
      #orientation-warning { font-size: 1.5rem; } 

      #start-screen {
        padding: 20px 15px; 
        justify-content: center; 
        align-items: center; 
        display: flex; 
        flex-direction: column; 
      }

      #start-screen h1 { 
        font-size: 2.2rem; 
        margin-bottom: 2rem; 
        line-height: 1.25; 
        text-align: center; 
      }

      #start-button, #restart-button { 
        padding: 12px 30px; 
        font-size: 1.1rem;  
        margin: 1rem 0;     
      }
      
      #start-screen #start-button {
        margin-top: 0; 
        margin-bottom: 1rem; 
      }
      
      #instructions { 
         bottom: 120px; 
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
  <div id="loading">
    <div class="loading-content">
      <h1>EXPLOSIVE TARGET SHOOTER</h1>
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress" id="progress"></div>
          <div class="progress-glow"></div>
        </div>
        <div class="loading-text" id="loading-text">LOADING ASSETS...</div>
      </div>
      <div class="hint">TAP START MISSION TO ENTER FULLSCREEN</div>
    </div>
  </div>

  <div id="start-screen">
    <h1>EXPLOSIVE TARGET SHOOTER</h1>
    <button id="start-button">START MISSION</button>
  </div>

  <div id="instructions">
    <p>DRAG or A/D KEYS to Strafe</p>
    <p>TAP SCREEN to Shoot</p>
    <p>SHOOT RED ENEMIES • COLLECT POWER-UPS (Reload/Health)</p>
    <p>WATCH TARGETS EXPLODE ON HIT!</p>
  </div>

  <div id="game-over">
    <h2>MISSION FAILED</h2>
    <div id="final-score">SCORE: 0</div>
    <button id="restart-button">TRY AGAIN</button>
  </div>

  <div id="level-up">LEVEL UP!</div>
  <div id="combo-display">COMBO x0</div>
  
  <div id="mobile-controls">
    <div class="mobile-btn" id="left-btn">←</div>
    <div class="mobile-btn" id="shoot-btn">FIRE</div>
    <div class="mobile-btn" id="right-btn">→</div>
  </div>

  <div id="orientation-warning">
    <div>Please rotate your device to landscape mode to play.</div>
  </div>

  <canvas id="hud"></canvas>

  <script>
  let scene, camera, renderer, ctx; 
  let targets = [];
  let projectiles = [];
  let explosions = [];
  let gameRunningGlobal = false; 
  let animateLights = () => {}; 
  let textureLoader; 

  const shootSound = new Audio('laser.mp3'); 
  shootSound.volume = 0.5; 
  const explosionSound = new Audio('explosion.mp3'); 
  const reloadSound = new Audio('reload.mp3'); 
  const backgroundMusic = new Audio('backgroundmusic.mp3'); 
  backgroundMusic.loop = true; 
  backgroundMusic.volume = 0.3; 
  
  function createExplosion(x, y, z) {
    if (!scene) { console.error("Scene not ready for explosion"); return null; }
    explosionSound.currentTime = 0;
    explosionSound.play().catch(e => console.warn("Error playing explosion sound:", e));

    const explosionData = {
      particles: [], position: new THREE.Vector3(x, y, z), timer: 30, active: true
    };
    const colors = [0xff0000, 0xff6600, 0xffff00, 0xffffff];
    for (let i = 0; i < 20; i++) {
      const particleGeom = new THREE.SphereGeometry(0.15, 6, 6);
      const particleMat = new THREE.MeshBasicMaterial({
        color: colors[Math.floor(Math.random() * colors.length)], transparent: true, opacity: 1.0
      });
      const particle = new THREE.Mesh(particleGeom, particleMat);
      particle.position.set(x, y, z);
      particle.userData = {
        velocity: new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5))
                  .normalize().multiplyScalar(Math.random() * 0.15 + 0.05),
      };
      explosionData.particles.push(particle);
      scene.add(particle); 
    }
    explosions.push(explosionData); 
    return explosionData;
  }

  function handleOrientation() {
    const orientationWarningEl = document.getElementById('orientation-warning');
    if (!orientationWarningEl) return; 
    const isPortrait = window.innerHeight > window.innerWidth;
    
    if (isPortrait) {
      orientationWarningEl.style.display = 'flex';
      if (gameRunningGlobal && backgroundMusic && !backgroundMusic.paused) { 
          backgroundMusic.pause();
      }
      gameRunningGlobal = false; 
    } else { 
      orientationWarningEl.style.display = 'none';
      const startScreenEl = document.getElementById('start-screen'); 
      if (!gameRunningGlobal && window.renderer && startScreenEl && !startScreenEl.style.display.includes('flex')) {
         gameRunningGlobal = true;
         if (backgroundMusic && backgroundMusic.paused) { 
            backgroundMusic.play().catch(e => console.warn("Error resuming background music:", e));
         }
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const loadingEl   = document.getElementById('loading'); 
    const progressEl  = document.getElementById('progress'); 
    const loadingTextEl = document.getElementById('loading-text'); 
    const startScr  = document.getElementById('start-screen');
    const gameOver  = document.getElementById('game-over');
    const startBtn  = document.getElementById('start-button');
    const restartBtn= document.getElementById('restart-button');

    const startFullscreen = () => {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(e => console.warn("Fullscreen request failed:", e));
      } else if (elem.webkitRequestFullscreen) { 
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) { 
        elem.msRequestFullscreen();
      }
    };

    if (!loadingEl || !progressEl || !loadingTextEl) {
        console.error("Critical loading screen elements (loading, progress, or loading-text) are missing from the DOM! Bypassing loading animation.");
        if(loadingEl) loadingEl.style.display = 'none';
        if(startScr) startScr.style.display = 'flex';
        return; 
    }

    let p=0, iv = setInterval(()=>{
      p += Math.random()*12;
      loadingTextEl.textContent = `LOADING ASSETS... ${Math.min(100, Math.round(p))}%`;
      if(p>=100){ p=100; clearInterval(iv);
        setTimeout(()=>{
          loadingEl.style.opacity='0'; 
          setTimeout(()=>{
            loadingEl.style.display='none';
            if (startScr) startScr.style.display='flex'; 
          },600); 
        },300);
      }
      progressEl.style.width = Math.min(100,p)+'%';
    },150); 

    if (startBtn) {
        startBtn.onclick = () => {
          if (startScr) startScr.style.display = 'none';
          startFullscreen();
          setTimeout(initGame, 100); 
        };
    }
    if (restartBtn) {
        restartBtn.onclick = ()=>{ 
            if (gameOver) gameOver.style.display='none'; 
            initGame(); 
        }
    }
    
    window.showGameOver = () => {
        const finalScoreEl = document.getElementById('final-score');
        if (finalScoreEl) finalScoreEl.textContent = `SCORE: ${window.finalScore || 0}`;
        if (gameOver) gameOver.style.display='flex';
    };

    handleOrientation(); 
    window.addEventListener('resize', handleOrientation);
    window.addEventListener('orientationchange', handleOrientation);
  });

  function createTarget(isEnemy, powerupType = 'reload_pack') {
      if (!scene || !textureLoader) { 
          console.error("[createTarget] ERROR: scene or textureLoader not initialized!");
          return null;
      }

      if (!isEnemy) { // POWER-UP
          let textureFile, planeColor, subType;
          let planeWidth = 1.5; 
          let planeHeight = 1.5;

          if (powerupType === 'reload_pack') {
              textureFile = 'powerup.png'; 
              planeColor = 0x44ccff; 
              subType = 'reload_pack';
              planeWidth = 1.8; 
              planeHeight = 1.8;
              console.log("[DEBUG] createTarget: Attempting to create RELOAD PACK sprite.");
          } else if (powerupType === 'health_pack') { 
              textureFile = 'health_pack.png';    
              planeColor = 0x44ff44; 
              subType = 'health_pack';
              // planeWidth = 1.5; // Default size is fine for health pack too
              // planeHeight = 1.5;
              console.log("[DEBUG] createTarget: Attempting to create HEALTH PACK sprite.");
          } else {
              console.warn("[createTarget] Unknown powerupType:", powerupType, "Cannot create powerup.");
              return null;
          }

          const powerupMaterial = new THREE.MeshBasicMaterial({
              transparent: true,
              alphaTest: 0.1,
              side: THREE.DoubleSide,
              color: planeColor 
          });

          textureLoader.load(
              textureFile,
              (loadedTexture) => {
                  console.log(`[SUCCESS] ${textureFile} texture LOADED for ${subType}!`);
                  powerupMaterial.map = loadedTexture;
                  powerupMaterial.color.set(0xffffff); 
                  powerupMaterial.needsUpdate = true;
              },
              undefined,
              (err) => {
                  console.error(`[CRITICAL FAILURE] ${textureFile} texture FAILED to load for ${subType}.`, err);
              }
          );
          
          const powerupGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
          const powerupPlane = new THREE.Mesh(powerupGeometry, powerupMaterial);

          const laneXPowerUp = (Math.floor(Math.random() * 3) - 1) * 6;
          const zPosPowerUp = -(Math.random() * 30 + 50);
          powerupPlane.position.set(laneXPowerUp, 1.2, zPosPowerUp);

          powerupPlane.userData = {
              type: 'powerup',
              subType: subType,
              hit: false,
              timer: 0,
              isBillboard: true
          };

          scene.add(powerupPlane); targets.push(powerupPlane);
          console.log(`[DEBUG] ${subType.toUpperCase()} PLANE added. Pos:`, powerupPlane.position.toArray().join(','), "World Size:", planeWidth, "x", planeHeight);
          return powerupPlane;

      } else { // ENEMY PLANE
          console.log("[DEBUG] createTarget: Attempting to create ENEMY PLANE with texture 'enemy1.png'.");

          const planeWidth = 3.0;  
          const planeHeight = 3.0; 

          const enemyGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
          const enemyMaterial = new THREE.MeshBasicMaterial({
              transparent: true,    
              alphaTest: 0.1,       
              side: THREE.DoubleSide,
              depthWrite: false, 
              color: 0xff00ff 
          });

          textureLoader.load(
              'enemy1.png', 
              function onLoad(loadedTexture) { 
                  console.log("[SUCCESS] enemy1.png texture LOADED for enemy plane! Applying to material.", loadedTexture);
                  enemyMaterial.map = loadedTexture;
                  enemyMaterial.color.set(0xffffff); 
                  enemyMaterial.needsUpdate = true;  
              },
              undefined, 
              function onError(err) { 
                  console.error("[CRITICAL FAILURE] enemy1.png texture FAILED to load for enemy. Using fallback color.", err);
              }
          );
          
          const enemyPlane = new THREE.Mesh(enemyGeometry, enemyMaterial);
          
          if (targets.filter(t => t.userData.type === 'enemy').length === 0) { 
            enemyPlane.position.set(0, 1.5, -20); 
            console.log("[DEBUG] First enemy plane spawned at TEST position (0, 1.5, -20).");
          } else {
            const regularLaneX = (Math.floor(Math.random() * 3) - 1) * 6;
            const regularZPos = -(Math.random() * 40 + 60);
            enemyPlane.position.set(regularLaneX, 1.5, regularZPos);
          }

          enemyPlane.userData = {
              type: 'enemy',
              hit: false,
              timer: 0,
              isBillboard: true 
          };

          scene.add(enemyPlane);
          targets.push(enemyPlane);
          console.log("[DEBUG] Enemy PLANE added to scene. World Size:", planeWidth, "x", planeHeight);
          return enemyPlane;
      }
  }

  function createCockpit() {
    const group = new THREE.Group();
    const material = new THREE.LineBasicMaterial({
      color: 0x00ffcc,
      opacity: 0.6,
      transparent: true
    });
    const vertices = new Float32Array([
      -1.2, -0.4, -1.2,  1.2, -0.4, -1.2,
       1.2, -0.4, -1.2,  0.8,  0.5, -0.7,
       0.8,  0.5, -0.7, -0.8,  0.5, -0.7,
      -0.8,  0.5, -0.7, -1.2, -0.4, -1.2
    ]);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const frame = new THREE.LineSegments(geometry, material);
    group.add(frame);
    group.position.set(0, 0, -0.6);
    return group;
  }


  function initGame(){
    console.log("[DEBUG] initGame started.");
    scene = new THREE.Scene(); 
    textureLoader = new THREE.TextureLoader();

    if (backgroundMusic && backgroundMusic.paused) {
        backgroundMusic.play().catch(e => console.warn("Error playing background music:", e));
    }

    function createTunnel() {
      const tunnelGeometry = new THREE.CylinderGeometry(50, 50, 300, 64, 1, true);
      const tunnelMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x222255, 
        transparent: true, 
        opacity: 0.6,     
        side: THREE.BackSide,
        specular: 0x111111, 
        shininess: 20
      });
      const tunnelMesh = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
      tunnelMesh.position.z = -150; 
      scene.add(tunnelMesh);

      const light1 = new THREE.PointLight(0x0066ff, 2, 100);
      light1.position.set(15, 5, -50); scene.add(light1);
      const light2 = new THREE.PointLight(0xff6600, 2, 100);
      light2.position.set(-15, 5, -80); scene.add(light2);

      return function animateTunnelLights(time) { 
        light1.intensity = 1.5 + Math.sin(time * 0.002) * 0.5;
        light2.intensity = 1.5 + Math.cos(time * 0.003) * 0.5;
        light1.position.z = -50 + Math.sin(time * 0.001) * 20;
        light2.position.z = -80 + Math.cos(time * 0.0015) * 20;
      };
    }

    if(window.renderer){ 
      cancelAnimationFrame(window.animId);
      if (window.renderer.domElement.parentNode) document.body.removeChild(window.renderer.domElement);
      targets.forEach(t => { 
          if (t.geometry) t.geometry.dispose(); 
          if (t.material) { 
              if (t.material.map) t.material.map.dispose(); 
              t.material.dispose(); 
          }
      });
      projectiles.forEach(p => {
          if (p.geometry) p.geometry.dispose(); if (p.material) p.material.dispose();
      });
      explosions.forEach(e => e.particles.forEach(particleMesh => {
          if (particleMesh.parent) particleMesh.parent.remove(particleMesh);
          if (particleMesh.geometry) particleMesh.geometry.dispose();
          if (particleMesh.material) particleMesh.material.dispose();
      }));
      window.renderer.dispose();
    }

    targets = []; projectiles = []; explosions = [];
    gameRunningGlobal = true; 

    scene.background = new THREE.Color(0x111133);
    // scene.fog = new THREE.FogExp2(0x111133, 0.02); 
    console.log("[DEBUG] Scene fog is currently disabled for testing.");

    camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,2,5);
    camera.lookAt(0, 1.5, -20); 
    console.log("[DEBUG] Camera forced to lookAt (0, 1.5, -20)");
    window.camera = camera; 

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.domElement.classList.add('webgl');
    document.body.appendChild(renderer.domElement);
    window.renderer = renderer; 

    const hudCanvas = document.getElementById('hud');
    if (!hudCanvas) { console.error("HUD canvas not found!"); return; } 
    hudCanvas.width  = innerWidth;
    hudCanvas.height = innerHeight;
    ctx = hudCanvas.getContext('2d');
    
    let health = 100, score = 0, penalties = 0, ammo = 15, maxAmmo = 15, lane = 0;
    let lastSpawnTime = 0, spawnInterval = 2500;
    let lastPowerupSpawnTime = 0, powerupSpawnInterval = 6000; // Init powerup timers
    let difficulty = 1, combo = 0, lastHitTime = 0; 
    let level = 1, scoreToNextLevel = 100, levelUpDisplayTime = 0, comboDisplayTime = 0;

    scene.add(new THREE.AmbientLight(0xffffff, 0.8)); 
    const d1 = new THREE.DirectionalLight(0xffffff, 1);
    d1.position.set(5,10,5); scene.add(d1);
    
    const muzzleFlash = new THREE.PointLight(0xffff00, 0, 10);
    muzzleFlash.position.set(0,0,-0.5);
    camera.add(muzzleFlash);
    camera.add(createCockpit());
    if (!camera.parent) scene.add(camera);

    const grid = new THREE.GridHelper(300,60,0x00ff88,0x224444);
    scene.add(grid);
    
    animateLights = createTunnel(); 
    
    function createProjectile() { 
        if(!scene || !camera) return null;
        const geometry = new THREE.SphereGeometry(0.2, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9 });
        const projectile = new THREE.Mesh(geometry, material);
        const projectileOffset = new THREE.Vector3(0, -0.2, -1);
        projectileOffset.applyQuaternion(camera.quaternion);
        projectile.position.copy(camera.position).add(projectileOffset);
        scene.add(projectile); projectiles.push(projectile);
        return projectile;
    }

    function trySpawnTarget(now) {
        const maxEnemies = 5;
        const maxReloadPacks = 1;
        const maxHealthPacks = 1;

        let currentEnemies = targets.filter(t => t.userData.type === 'enemy').length;
        let currentReloadPacks = targets.filter(t => t.userData.type === 'powerup' && t.userData.subType === 'reload_pack').length;
        let currentHealthPacks = targets.filter(t => t.userData.type === 'powerup' && t.userData.subType === 'health_pack').length;

        if (currentEnemies < maxEnemies) {
            if (now - lastSpawnTime > spawnInterval) {
                createTarget(true);
                lastSpawnTime = now;
                spawnInterval = Math.max(800, spawnInterval * 0.985);
            }
        }

        if (now - lastPowerupSpawnTime > powerupSpawnInterval) {
            let powerupSpawnedThisCycle = false;
            if (currentHealthPacks < maxHealthPacks && Math.random() < 0.25) { 
                createTarget(false, 'health_pack');
                powerupSpawnedThisCycle = true;
            }
            else if (currentReloadPacks < maxReloadPacks && Math.random() < 0.35) { 
                createTarget(false, 'reload_pack');
                powerupSpawnedThisCycle = true;
            }

            if (powerupSpawnedThisCycle) {
                lastPowerupSpawnTime = now; 
                powerupSpawnInterval = Math.max(4000, powerupSpawnInterval * 0.995); 
            }
        }
    }
    
    let isDragging = false, dragStartX = 0, cameraStartX = 0;
    let pointerDownTime = 0;
    let pointerDownX = 0;
    const TAP_MAX_DURATION = 250; 
    const TAP_MAX_DISTANCE = 15;  

    renderer.domElement.addEventListener('pointerdown', e => {
      if (e.button !== 0 || !gameRunningGlobal) return; 
      isDragging = true; 
      dragStartX = e.clientX; 
      cameraStartX = camera.position.x;
      pointerDownTime = performance.now();
      pointerDownX = e.clientX;
    }, { passive: false });

    renderer.domElement.addEventListener('pointermove', e => {
      if (!isDragging || !gameRunningGlobal) return;
      const distanceMovedSinceDown = Math.abs(e.clientX - pointerDownX);
      if (distanceMovedSinceDown < TAP_MAX_DISTANCE && performance.now() - pointerDownTime < TAP_MAX_DURATION) {
          return; 
      }
      const dx = e.clientX - dragStartX;
      const targetX = cameraStartX - dx * 0.035;
      camera.position.x = THREE.MathUtils.clamp(targetX, -10, 10);
      lane = Math.max(-1, Math.min(1, Math.round(camera.position.x / 6)));
    }, { passive: false });

    renderer.domElement.addEventListener('pointerup', e => {
      if (e.button !== 0 || !gameRunningGlobal) {
        if (isDragging) isDragging = false; 
        return;
      }
      if (isDragging) { 
        const upTime = performance.now();
        const duration = upTime - pointerDownTime;
        const distanceMoved = Math.abs(e.clientX - pointerDownX);
        if (duration < TAP_MAX_DURATION && distanceMoved < TAP_MAX_DISTANCE) {
          if (e.target === renderer.domElement) { 
            handleShoot();
          }
        }
      }
      isDragging = false; 
    });

    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');
    const shootBtn = document.getElementById('shoot-btn'); 
    if(leftBtn) leftBtn.addEventListener('pointerdown', (e) => { e.stopPropagation(); if(gameRunningGlobal) lane = Math.max(-1, lane - 1); });
    if(rightBtn) rightBtn.addEventListener('pointerdown', (e) => { e.stopPropagation(); if(gameRunningGlobal) lane = Math.min(1, lane + 1); });
    if(shootBtn) shootBtn.addEventListener('pointerdown', (e) => { e.stopPropagation(); handleShoot(); });
    
    window.addEventListener('keydown', e => {
        if (!gameRunningGlobal) return;
        if(e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') lane = Math.max(-1, lane - 1);
        if(e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') lane = Math.min(1, lane + 1);
        if(e.code === 'Space' || e.key.toLowerCase() === 'w' || e.key === 'Enter') { e.preventDefault(); handleShoot(); }
        if(e.key.toLowerCase() === 'r') handleReload(false); 
    });
    
    function showLevelUp() { 
      const levelUpEl = document.getElementById('level-up');
      if (levelUpEl) { 
        levelUpEl.textContent = `LEVEL ${level}!`;
        levelUpEl.style.transform = 'translate(-50%, -50%) scale(0.5)';
        levelUpEl.style.opacity = '1';
        setTimeout(() => { if(levelUpEl) levelUpEl.style.transform = 'translate(-50%, -50%) scale(1.2)'; }, 50);
        setTimeout(() => { if(levelUpEl) levelUpEl.style.transform = 'translate(-50%, -50%) scale(1)'; }, 400);
        levelUpDisplayTime = performance.now();
      }
    }
    function showCombo(comboValue) { 
      const comboEl = document.getElementById('combo-display');
      if (comboEl) { 
        comboEl.textContent = `COMBO x${comboValue}!`;
        comboEl.style.transform = 'translate(-50%, -50%) scale(1.5)';
        comboEl.style.opacity = '1';
        setTimeout(() => { if(comboEl) comboEl.style.transform = 'translate(-50%, -50%) scale(1)'; }, 50);
        comboDisplayTime = performance.now();
      }
    }

    function handleShoot() { 
      if(!gameRunningGlobal || ammo <= 0 || !camera) return;
      
      if (ammo <=0 && gameRunningGlobal) { 
          const originalZ = camera.position.z;
          camera.position.z += 0.1; 
          setTimeout(() => { if(camera) camera.position.z = originalZ; }, 80);
          return;
      }
      if (shootSound) { 
        shootSound.currentTime = 0;
        shootSound.play().catch(e => console.warn("Error playing shoot sound:", e));
      }

      ammo--;
      muzzleFlash.intensity = 15; setTimeout(() => { muzzleFlash.intensity = 0; }, 60);
      const projectile = createProjectile();
      if (!projectile) return; 
      const direction = new THREE.Vector3(0,0,-1); direction.applyQuaternion(camera.quaternion);
      projectile.userData = { velocity: direction.multiplyScalar(1.8), timer: 100 };
    }

    function handleReload(isFromPowerup = false) { 
        if (!isFromPowerup) {
             console.log("[INFO] Manual reload (R key) disabled. Collect a power-up!");
             return; 
        }

        if (ammo < maxAmmo && gameRunningGlobal && camera && scene) {
            console.log("[RELOAD] Reloading ammo via power-up!");
            if (reloadSound) {
                reloadSound.currentTime = 0;
                reloadSound.play().catch(e => console.warn("Error playing reload sound:", e));
            }

            ammo = maxAmmo; 
            const originalZ = camera.position.z;
            camera.position.z += 0.2;
            setTimeout(() => { if (camera) camera.position.z = originalZ; }, 120);
            const reloadFlash = new THREE.PointLight(0x0066ff, 8, 15);
            reloadFlash.position.copy(camera.position);
            scene.add(reloadFlash);
            setTimeout(() => { if (scene) scene.remove(reloadFlash); reloadFlash.dispose(); }, 250);
        } else if (ammo >= maxAmmo && isFromPowerup) {
            console.log("[INFO] Ammo already full, reload power-up had no effect.");
        }
    }
    
    function drawHUD() {
      if (!ctx) return; 
      ctx.clearRect(0,0,innerWidth,innerHeight);
      const gameOverEl = document.getElementById('game-over');
      if (!gameRunningGlobal && (window.finalScore === undefined || window.finalScore === null) && gameOverEl && !gameOverEl.style.display.includes('flex')) return;
      
      ctx.strokeStyle = 'rgba(0,255,255,0.8)'; ctx.lineWidth = 3;
      const reticleSize = 20 + Math.sin(performance.now()/200)*3; const gap = 8;
      ctx.beginPath(); ctx.arc(innerWidth/2, innerHeight/2, reticleSize*1.5, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(innerWidth/2 - reticleSize - gap, innerHeight/2 - reticleSize - gap);
      ctx.lineTo(innerWidth/2 - gap, innerHeight/2 - gap);
      ctx.moveTo(innerWidth/2 + reticleSize + gap, innerHeight/2 - reticleSize - gap);
      ctx.lineTo(innerWidth/2 + gap, innerHeight/2 - gap);
      ctx.moveTo(innerWidth/2 - reticleSize - gap, innerHeight/2 + reticleSize + gap);
      ctx.lineTo(innerWidth/2 - gap, innerHeight/2 + gap);
      ctx.moveTo(innerWidth/2 + reticleSize + gap, innerHeight/2 + reticleSize + gap);
      ctx.lineTo(innerWidth/2 + gap, innerHeight/2 + gap);
      ctx.stroke();
      
      const panelWidth = 260; ctx.save();
      ctx.fillStyle = 'rgba(0,20,40,0.6)'; ctx.strokeStyle = 'rgba(0,255,255,0.4)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.roundRect(20, 20, panelWidth, 150, [0, 15, 15, 0]); ctx.fill(); ctx.stroke();
      
      ctx.fillStyle = 'rgba(0,50,100,0.4)'; ctx.beginPath();
      ctx.roundRect(30, 30, panelWidth-20, 25, 12); ctx.fill();
      
      const healthWidth = (panelWidth-20) * (health/100);
      const healthGrad = ctx.createLinearGradient(30, 30, 30+healthWidth, 30);
      healthGrad.addColorStop(0, '#00ff88'); healthGrad.addColorStop(1, '#0066ff');
      ctx.fillStyle = healthGrad; ctx.beginPath();
      ctx.roundRect(30, 30, Math.max(0, healthWidth), 25, 12); ctx.fill(); 
      
      ctx.font = 'bold 16px Orbitron'; ctx.fillStyle = '#ffffff';
      ctx.fillText(`HEALTH: ${Math.floor(health)}%`, 40, 50);
      ctx.font = 'bold 18px Orbitron'; ctx.fillStyle = '#00ffff';
      ctx.fillText(`SCORE: ${score}`, 40, 80);
      ctx.fillText(`LEVEL: ${level}`, 40, 110);
      
      ctx.fillStyle = ammo > maxAmmo/3 ? 'rgba(0,255,255,0.7)' : 'rgba(255,50,50,0.7)';
      ctx.font = 'bold 20px Orbitron'; ctx.fillText(`AMMO: ${ammo}/${maxAmmo}`, 40, 140);
      ctx.restore();
    }

    function doGameOver(){ 
      gameRunningGlobal = false; 
      window.finalScore = score;
      if (backgroundMusic && !backgroundMusic.paused) {
          backgroundMusic.pause();
      }
      setTimeout(() => {
          if (typeof window.showGameOver === 'function') window.showGameOver();
      }, 500);
    }
    
    let gameStartTime = 0; 
    function animate(time){ 
      window.animId = requestAnimationFrame(animate);
      if (!gameStartTime && time) gameStartTime = time; 
      const now = performance.now(); 
      
      if (typeof animateLights === 'function') animateLights(now);

      const levelUpEl = document.getElementById('level-up');
      const comboEl = document.getElementById('combo-display');

      if(levelUpDisplayTime > 0 && now - levelUpDisplayTime > 2000) {
        if(levelUpEl) levelUpEl.style.opacity = '0'; 
        levelUpDisplayTime = 0;
      }
      if(comboDisplayTime > 0 && now - comboDisplayTime > 1500) {
        if(comboEl) comboEl.style.opacity = '0';
        comboDisplayTime = 0;
      }

      if(gameRunningGlobal && camera && scene){ 
        difficulty = 1 + (now - (gameStartTime || now) ) / 60000; 
        const targetCameraX = lane * 6;
        camera.position.x += (targetCameraX - camera.position.x) * 0.12;

        trySpawnTarget(now);

        explosions = explosions.filter(explosion => { 
          explosion.timer--;
          explosion.particles.forEach(p_mesh => {
            p_mesh.position.add(p_mesh.userData.velocity);
            p_mesh.userData.velocity.multiplyScalar(0.93);
            if (p_mesh.material.opacity !== undefined) p_mesh.material.opacity = Math.max(0, explosion.timer / 30);
          });
          if (explosion.timer <= 0) {
              explosion.particles.forEach(p_mesh => {
                  if (p_mesh.parent) p_mesh.parent.remove(p_mesh);
                  if (p_mesh.geometry) p_mesh.geometry.dispose();
                  if (p_mesh.material) p_mesh.material.dispose();
              }); return false;
          } return true;
        });

        targets = targets.filter(t => { 
          t.position.z += 0.1 * difficulty; 
          if (t.userData && t.userData.isBillboard && camera) { 
             t.quaternion.copy(camera.quaternion);
          }

          // Player Collision with Power-ups
          if (t.userData.type === 'powerup' && !t.userData.hit) {
              const distanceToPlayerZ = Math.abs(t.position.z - camera.position.z);
              const powerupLane = Math.round(t.position.x / 6);
              if (distanceToPlayerZ < 1.0 && powerupLane === lane) { 
                  t.userData.hit = true; 
                  t.userData.timer = 1;  
                  if (t.userData.subType === 'reload_pack') {
                      handleReload(true); 
                  } else if (t.userData.subType === 'health_pack') {
                      const healthGained = 25; 
                      health = Math.min(100, health + healthGained); 
                      console.log(`[POWERUP] Health pack collected! Gained: ${healthGained}, Total Health: ${health}`);
                  }
              }
          }
          
          if (t.position.z > camera.position.z + 1) { 
            if(!t.userData.hit){
              if(t.userData.type === 'enemy') { 
                  health -= 15; 
                  combo = 0; 
              }
            }
            if(scene) scene.remove(t); 
            if(t.material) { 
                if(t.material.map) t.material.map.dispose(); 
                t.material.dispose(); 
            }
            if (t.geometry) t.geometry.dispose(); 
            return false;
          }
          if(t.userData.hit){ 
            if (t.material && t.material.opacity !== undefined) t.material.opacity = Math.max(0, (t.userData.timer / 20));
            t.userData.timer--;
            if(t.userData.timer <= 0) {
              if(scene) scene.remove(t); 
              if(t.material) { 
                  if(t.material.map) t.material.map.dispose(); 
                  t.material.dispose(); 
              }
               if (t.geometry) t.geometry.dispose(); 
              return false;
            }
          } return true;
        });
        
        projectiles = projectiles.filter(p => { 
          p.position.add(p.userData.velocity); p.userData.timer--;
          const pBox = new THREE.Box3().setFromObject(p); let hitSomething = false;
          for (let i = targets.length - 1; i >= 0; i--) {
            const t = targets[i]; 
            if (t.userData.hit) continue; 
            if (t.userData.type !== 'enemy') continue; 

            const tBox = new THREE.Box3().setFromObject(t);
            if (pBox.intersectsBox(tBox)) {
              t.userData.hit = true; t.userData.timer = 20; 
              const nowPerf = performance.now();
              combo = (nowPerf - lastHitTime < 2000) ? combo + 1 : 1; 
              lastHitTime = nowPerf;
              createExplosion(t.position.x, t.position.y, t.position.z); 
              score += 10 + Math.floor(combo/3); if(combo > 2) showCombo(combo);
              if(score >= scoreToNextLevel) {
                  console.log(`[LEVEL UP] Score: ${score}, NextLevelScore: ${scoreToNextLevel}, Old Level: ${level}`);
                  level++; 
                  scoreToNextLevel += level * 100; 
                  console.log(`           New Level: ${level}, New NextLevelScore: ${scoreToNextLevel}`);
                  maxAmmo += 5; 
                  ammo = maxAmmo; 
                  health = Math.min(100, health + 30); 
                  showLevelUp();
              }
              hitSomething = true; break;
            }
          }
          if (hitSomething || p.userData.timer <= 0 || p.position.z < -100) {
            if(scene) scene.remove(p); 
            if(p.geometry) p.geometry.dispose(); 
            if(p.material) p.material.dispose(); 
            return false;
          } return true;
        });

        if(health <= 0) { health = 0; doGameOver(); }
      }
      if(renderer && camera && scene) renderer.render(scene,camera); 
      if(ctx) drawHUD();
    }

    gameStartTime = performance.now(); 
    console.log("[DEBUG] Spawning ONE test enemy plane, ONE reload pack, and ONE health pack...");
    createTarget(true); 
    createTarget(false, 'reload_pack'); 
    createTarget(false, 'health_pack'); 
    lastSpawnTime = performance.now(); 
    lastPowerupSpawnTime = performance.now();
    spawnInterval = 2500; 
    powerupSpawnInterval = 6000;
    
    if (scene && scene.children) {
      console.log("[DEBUG] Scene children just before first animate call:", scene.children.map(c => c.type + (c.userData && c.userData.type ? ` (${c.userData.type})` : '')));
    }

    if (typeof animate === 'function') {
        animate(performance.now());
        console.log("[DEBUG] Initial animate() called.");
    } else {
        console.error("[CRITICAL] animate function is not defined!");
    }
  }
  
  window.addEventListener('resize', () => {
    if (!window.renderer || !window.camera) return;
    window.camera.aspect = window.innerWidth / window.innerHeight;
    window.camera.updateProjectionMatrix();
    window.renderer.setSize(window.innerWidth, window.innerHeight);
    const hud = document.getElementById('hud');
    if (hud) {
      hud.width = window.innerWidth;
      hud.height = window.innerHeight;
    }
    handleOrientation(); 
  });
  </script>
</body>
</html>
