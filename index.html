<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Super Eva's Magic Bus Ride</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      overflow: hidden;
      background: radial-gradient(circle at top, #fef6ff 0%, #cce7ff 45%, #fff7cc 100%);
      font-family: "Comic Sans MS", "Trebuchet MS", sans-serif;
      color: #4b3b6b;
      touch-action: none;
    }
    canvas {
      display: block;
      position: absolute;
      inset: 0;
    }
    #ui {
      z-index: 2;
      pointer-events: none;
    }
    #hud {
      position: absolute;
      inset: 0;
      z-index: 3;
      pointer-events: none;
    }
    #title {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 24px;
      border-radius: 999px;
      font-size: 1.4rem;
      color: #6b4fc7;
      box-shadow: 0 8px 20px rgba(126, 87, 194, 0.2);
      z-index: 4;
      text-align: center;
      letter-spacing: 0.5px;
    }
    #letter-popup {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(3rem, 10vw, 6rem);
      color: #ff6fae;
      text-shadow: 0 6px 18px rgba(255, 111, 174, 0.5);
      opacity: 0;
      transition: opacity 0.25s ease;
      z-index: 4;
      pointer-events: none;
    }
    #helper {
      position: absolute;
      bottom: 18px;
      width: 100%;
      text-align: center;
      font-size: 1rem;
      color: #5a5a8f;
      z-index: 4;
      text-shadow: 0 2px 6px rgba(255, 255, 255, 0.8);
    }
  </style>
</head>
<body>
  <div id="title">Super Eva's Magic Bus Ride</div>
  <div id="letter-popup"></div>
  <div id="helper">Tap a bubble to pop it with your magic wand!</div>
  <canvas id="webgl"></canvas>
  <canvas id="ui"></canvas>
  <canvas id="hud"></canvas>

  <script src="three.min.js"></script>
  <script>
    const canvas = document.getElementById("webgl");
    const uiCanvas = document.getElementById("ui");
    const hudCanvas = document.getElementById("hud");
    const letterPopup = document.getElementById("letter-popup");

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xf7e9ff, 6, 32);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.5, 5);

    const ambient = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambient);
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
    mainLight.position.set(4, 6, 5);
    scene.add(mainLight);

    const uiCtx = uiCanvas.getContext("2d");
    const hudCtx = hudCanvas.getContext("2d");

    const pastelColors = [0xffc1e3, 0xb5e4ff, 0xfff0a6];

    const tunnelGroup = new THREE.Group();
    const ringCount = 20;
    const ringSpacing = 2.2;
    for (let i = 0; i < ringCount; i++) {
      const color = pastelColors[i % pastelColors.length];
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(6, 0.12, 12, 80),
        new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 })
      );
      ring.position.z = -i * ringSpacing;
      ring.rotation.x = Math.PI / 2;
      tunnelGroup.add(ring);
    }
    scene.add(tunnelGroup);

    const roadMaterial = new THREE.MeshStandardMaterial({ color: 0xffe2f4, roughness: 0.4, metalness: 0.1 });
    const road = new THREE.Mesh(new THREE.PlaneGeometry(14, 80), roadMaterial);
    road.rotation.x = -Math.PI / 2;
    road.position.y = -0.2;
    road.position.z = -25;
    scene.add(road);

    const skyGlow = new THREE.Mesh(
      new THREE.SphereGeometry(30, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xe6f7ff, side: THREE.BackSide })
    );
    scene.add(skyGlow);

    const busGroup = new THREE.Group();
    const busBody = new THREE.Mesh(
      new THREE.BoxGeometry(2.2, 1, 1.4),
      new THREE.MeshStandardMaterial({ color: 0xff9ad5 })
    );
    busBody.position.y = 0.1;
    busGroup.add(busBody);
    const busTop = new THREE.Mesh(
      new THREE.BoxGeometry(1.6, 0.6, 1.2),
      new THREE.MeshStandardMaterial({ color: 0xffc75f })
    );
    busTop.position.set(0, 0.8, 0);
    busGroup.add(busTop);
    const windowMaterial = new THREE.MeshStandardMaterial({ color: 0xa6e6ff, transparent: true, opacity: 0.85 });
    const windowGeometry = new THREE.PlaneGeometry(1.2, 0.4);
    const busWindowLeft = new THREE.Mesh(windowGeometry, windowMaterial);
    busWindowLeft.position.set(-1.05, 0.25, 0);
    busWindowLeft.rotation.y = Math.PI / 2;
    busGroup.add(busWindowLeft);
    const busWindowRight = busWindowLeft.clone();
    busWindowRight.position.set(1.05, 0.25, 0);
    busWindowRight.rotation.y = -Math.PI / 2;
    busGroup.add(busWindowRight);
    const busFrontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
    busFrontWindow.position.set(0, 0.25, 0.72);
    busFrontWindow.rotation.y = Math.PI;
    busGroup.add(busFrontWindow);
    const heart = new THREE.Mesh(
      new THREE.ShapeGeometry(
        new THREE.Shape()
          .moveTo(0, 0.2)
          .bezierCurveTo(0, 0.2, -0.3, -0.1, -0.3, -0.35)
          .bezierCurveTo(-0.3, -0.6, 0, -0.7, 0, -0.9)
          .bezierCurveTo(0, -0.7, 0.3, -0.6, 0.3, -0.35)
          .bezierCurveTo(0.3, -0.1, 0, 0.2, 0, 0.2)
      ),
      new THREE.MeshStandardMaterial({ color: 0xff6fae })
    );
    heart.position.set(0, 0.1, 0.72);
    heart.scale.setScalar(0.6);
    busGroup.add(heart);
    const wheelGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.5, 12);
    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a6a });
    [-0.8, 0.8].forEach((x) => {
      const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheel.rotation.z = Math.PI / 2;
      wheel.position.set(x, -0.2, 0.65);
      busGroup.add(wheel);
      const wheel2 = wheel.clone();
      wheel2.position.z = -0.65;
      busGroup.add(wheel2);
    });
    const heroBody = new THREE.Mesh(
      new THREE.CylinderGeometry(0.2, 0.28, 0.6, 12),
      new THREE.MeshStandardMaterial({ color: 0x7aa7ff })
    );
    heroBody.position.set(0, 1.1, 0);
    busGroup.add(heroBody);
    const heroHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.22, 16, 16),
      new THREE.MeshStandardMaterial({ color: 0xffd6c2 })
    );
    heroHead.position.set(0, 1.6, 0);
    busGroup.add(heroHead);
    const heroCape = new THREE.Mesh(
      new THREE.PlaneGeometry(0.6, 0.9),
      new THREE.MeshStandardMaterial({ color: 0xff6fae, side: THREE.DoubleSide })
    );
    heroCape.position.set(0, 1.05, -0.35);
    heroCape.rotation.x = -0.3;
    busGroup.add(heroCape);

    const wand = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04, 0.04, 0.6, 8),
      new THREE.MeshStandardMaterial({ color: 0xfdf6ff })
    );
    wand.position.set(0.5, 1.25, 0.2);
    wand.rotation.z = Math.PI / 4;
    busGroup.add(wand);
    const wandTip = new THREE.Mesh(
      new THREE.SphereGeometry(0.09, 12, 12),
      new THREE.MeshStandardMaterial({ color: 0xfff3a1, emissive: 0xfff3a1 })
    );
    wandTip.position.set(0.7, 1.5, 0.35);
    busGroup.add(wandTip);

    busGroup.position.set(0, -0.2, 3.5);
    scene.add(busGroup);

    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const numbers = Array.from({ length: 20 }, (_, i) => String(i + 1));
    const bubbleLabels = [...letters, ...numbers];

    function makeTextSprite(text) {
      const size = 256;
      const textCanvas = document.createElement("canvas");
      textCanvas.width = size;
      textCanvas.height = size;
      const ctx = textCanvas.getContext("2d");
      ctx.fillStyle = "rgba(255, 255, 255, 0.0)";
      ctx.fillRect(0, 0, size, size);
      ctx.font = "bold 120px Comic Sans MS";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#6b4fc7";
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 10;
      ctx.strokeText(text, size / 2, size / 2 + 4);
      ctx.fillText(text, size / 2, size / 2 + 4);

      const texture = new THREE.CanvasTexture(textCanvas);
      texture.minFilter = THREE.LinearFilter;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(1.2, 1.2, 1.2);
      return sprite;
    }

    const bubbles = [];
    const poppingBubbles = new Set();
    const bubbleCount = 18;
    const bubbleGeometry = new THREE.SphereGeometry(0.45, 20, 20);
    const bubbleMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.55,
      roughness: 0.2,
      metalness: 0.1
    });

    function spawnBubble(existingBubble) {
      const label = bubbleLabels[Math.floor(Math.random() * bubbleLabels.length)];
      const bubble = existingBubble || new THREE.Mesh(bubbleGeometry, bubbleMaterial.clone());
      bubble.material.color.setHSL(Math.random(), 0.4, 0.85);
      bubble.material.opacity = 0.55;
      bubble.scale.setScalar(1);
      bubble.position.set(
        (Math.random() - 0.5) * 10,
        1 + Math.random() * 4,
        -10 - Math.random() * 40
      );
      bubble.userData = {
        label,
        floatOffset: Math.random() * Math.PI * 2,
        sprite: bubble.userData ? bubble.userData.sprite : null,
        popProgress: 0
      };
      if (bubble.userData.sprite) {
        bubble.remove(bubble.userData.sprite);
      }
      const sprite = makeTextSprite(label);
      sprite.position.set(0, 0, 0.6);
      bubble.add(sprite);
      bubble.userData.sprite = sprite;
      if (!existingBubble) {
        scene.add(bubble);
        bubbles.push(bubble);
      }
    }

    for (let i = 0; i < bubbleCount; i++) {
      spawnBubble();
    }

    const sparkles = [];
    const magicBursts = [];
    function addSparkles(screenX, screenY) {
      for (let i = 0; i < 18; i++) {
        sparkles.push({
          x: screenX,
          y: screenY,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.7) * 3,
          life: 1
        });
      }
    }

    function showLetter(label) {
      letterPopup.textContent = label;
      letterPopup.style.opacity = "1";
      clearTimeout(showLetter._timeout);
      showLetter._timeout = setTimeout(() => {
        letterPopup.style.opacity = "0";
      }, 900);
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function handleTap(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      pointer.x = x * 2 - 1;
      pointer.y = -(y * 2 - 1);

      raycaster.setFromCamera(pointer, camera);

      let closestBubble = null;
      let closestDistance = Infinity;
      bubbles.forEach((bubble) => {
        if (bubble.userData.popProgress > 0) {
          return;
        }
        const distanceToRay = raycaster.ray.distanceToPoint(bubble.position);
        if (distanceToRay < 1.4) {
          const camDistance = bubble.position.distanceTo(camera.position);
          if (camDistance < closestDistance) {
            closestDistance = camDistance;
            closestBubble = bubble;
          }
        }
      });

      if (closestBubble) {
        const label = closestBubble.userData.label;
        const vector = closestBubble.position.clone().project(camera);
        const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const screenY = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        addSparkles(screenX, screenY);
        showLetter(label);
        closestBubble.userData.popProgress = 0.01;
        poppingBubbles.add(closestBubble);
        magicBursts.push({
          start: performance.now(),
          x: screenX,
          y: screenY
        });
      }
    }

    window.addEventListener("pointerdown", (event) => {
      handleTap(event);
    });

    function resize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      uiCanvas.width = window.innerWidth;
      uiCanvas.height = window.innerHeight;
      hudCanvas.width = window.innerWidth;
      hudCanvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    let lastTime = 0;
    const speed = 0.04;

    function animate(time) {
      requestAnimationFrame(animate);
      const delta = (time - lastTime) / 16.666;
      lastTime = time;

      tunnelGroup.children.forEach((ring) => {
        ring.position.z += speed * delta;
        if (ring.position.z > camera.position.z) {
          ring.position.z = -ringCount * ringSpacing;
        }
      });

      bubbles.forEach((bubble) => {
        if (bubble.userData.popProgress <= 0) {
          bubble.position.z += speed * 1.2 * delta;
        }
        bubble.position.y += Math.sin(time * 0.002 + bubble.userData.floatOffset) * 0.005;
        if (bubble.position.z > camera.position.z + 1) {
          spawnBubble(bubble);
        }
      });

      poppingBubbles.forEach((bubble) => {
        bubble.userData.popProgress += 0.08;
        const scale = Math.max(0, 1 - bubble.userData.popProgress);
        bubble.scale.setScalar(scale);
        bubble.material.opacity = Math.max(0, 0.55 * scale);
        if (bubble.userData.popProgress >= 1) {
          poppingBubbles.delete(bubble);
          spawnBubble(bubble);
        }
      });

      busGroup.position.y = -0.1 + Math.sin(time * 0.003) * 0.05;
      wandTip.scale.setScalar(1 + Math.sin(time * 0.01) * 0.1);

      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
      sparkles.forEach((sparkle) => {
        sparkle.x += sparkle.vx;
        sparkle.y += sparkle.vy;
        sparkle.life -= 0.03;
      });
      for (let i = sparkles.length - 1; i >= 0; i--) {
        if (sparkles[i].life <= 0) {
          sparkles.splice(i, 1);
        }
      }
      sparkles.forEach((sparkle) => {
        uiCtx.beginPath();
        uiCtx.fillStyle = `rgba(255, 215, 130, ${sparkle.life})`;
        uiCtx.arc(sparkle.x, sparkle.y, 4, 0, Math.PI * 2);
        uiCtx.fill();
      });

      hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
      const now = performance.now();
      const wandWorld = new THREE.Vector3();
      wandTip.getWorldPosition(wandWorld);
      const wandScreen = wandWorld.clone().project(camera);
      const wandScreenX = (wandScreen.x * 0.5 + 0.5) * window.innerWidth;
      const wandScreenY = (-wandScreen.y * 0.5 + 0.5) * window.innerHeight;
      for (let i = magicBursts.length - 1; i >= 0; i--) {
        const burst = magicBursts[i];
        const age = (now - burst.start) / 450;
        if (age > 1) {
          magicBursts.splice(i, 1);
          continue;
        }
        const alpha = 1 - age;
        hudCtx.strokeStyle = `rgba(255, 221, 122, ${alpha})`;
        hudCtx.lineWidth = 4;
        hudCtx.beginPath();
        hudCtx.moveTo(wandScreenX, wandScreenY);
        hudCtx.lineTo(burst.x, burst.y);
        hudCtx.stroke();
        hudCtx.fillStyle = `rgba(255, 182, 233, ${alpha})`;
        hudCtx.beginPath();
        hudCtx.arc(burst.x, burst.y, 12 + age * 8, 0, Math.PI * 2);
        hudCtx.fill();
      }
      hudCtx.beginPath();
      hudCtx.strokeStyle = "rgba(255,255,255,0.7)";
      hudCtx.lineWidth = 3;
      hudCtx.arc(window.innerWidth / 2, window.innerHeight / 2, 20, 0, Math.PI * 2);
      hudCtx.stroke();

      renderer.render(scene, camera);
    }

    animate(0);
  </script>
</body>
</html>
