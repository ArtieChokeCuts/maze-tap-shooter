<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Super Eva's Magic Bus Ride</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      overflow: hidden;
      background: #87ceeb;
      font-family: "Comic Sans MS", "Trebuchet MS", sans-serif;
      color: #4b3b6b;
      touch-action: none;
    }
    #splash-screen {
      position: fixed;
      inset: 0;
      background: url("splash.png") center center / cover no-repeat;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #start-button {
      border: none;
      background: #ffe44d;
      color: #5c3d00;
      font-size: 1.8rem;
      padding: 16px 40px;
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(255, 228, 77, 0.5);
      animation: pulse 1.6s ease-in-out infinite;
    }
    #start-button:focus-visible {
      outline: 4px solid rgba(255, 255, 255, 0.8);
      outline-offset: 4px;
    }
    @keyframes pulse {
      0% {
        transform: scale(1);
        box-shadow: 0 12px 30px rgba(255, 228, 77, 0.5);
      }
      50% {
        transform: scale(1.08);
        box-shadow: 0 16px 40px rgba(255, 228, 77, 0.75);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 12px 30px rgba(255, 228, 77, 0.5);
      }
    }
    canvas {
      display: block;
      position: absolute;
      inset: 0;
    }
    #ui {
      z-index: 2;
      pointer-events: none;
    }
    #hud {
      position: absolute;
      inset: 0;
      z-index: 3;
      pointer-events: none;
    }
    #title {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 24px;
      border-radius: 999px;
      font-size: 1.4rem;
      color: #6b4fc7;
      box-shadow: 0 8px 20px rgba(126, 87, 194, 0.2);
      z-index: 4;
      text-align: center;
      letter-spacing: 0.5px;
    }
    #letter-popup {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(3rem, 10vw, 6rem);
      color: #ff6fae;
      text-shadow: 0 6px 18px rgba(255, 111, 174, 0.5);
      opacity: 0;
      transition: opacity 0.25s ease;
      z-index: 4;
      pointer-events: none;
    }
    #helper {
      position: absolute;
      bottom: 18px;
      width: 100%;
      text-align: center;
      font-size: 1rem;
      color: #5a5a8f;
      z-index: 4;
      text-shadow: 0 2px 6px rgba(255, 255, 255, 0.8);
    }
  </style>
</head>
<body>
  <div id="splash-screen">
    <button id="start-button" type="button">START GAME</button>
  </div>
  <div id="title">Super Eva's Magic Bus Ride</div>
  <div id="letter-popup"></div>
  <div id="helper">Tap a bubble to pop it with your magic wand!</div>
  <canvas id="webgl"></canvas>
  <canvas id="ui"></canvas>
  <canvas id="hud"></canvas>

  <script src="three.min.js"></script>
  <script>
    const canvas = document.getElementById("webgl");
    const uiCanvas = document.getElementById("ui");
    const hudCanvas = document.getElementById("hud");
    const letterPopup = document.getElementById("letter-popup");
    const splashScreen = document.getElementById("splash-screen");
    const startButton = document.getElementById("start-button");

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xf7e9ff, 6, 32);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.5, 5);

    const ambient = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambient);
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
    mainLight.position.set(4, 6, 5);
    scene.add(mainLight);

    const uiCtx = uiCanvas.getContext("2d");
    const hudCtx = hudCanvas.getContext("2d");

    const skyGlow = new THREE.Mesh(
      new THREE.SphereGeometry(30, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xe6f7ff, side: THREE.BackSide })
    );
    scene.add(skyGlow);

    const busGroup = new THREE.Group();
    const hoverBus = new THREE.Mesh(
      new THREE.BoxGeometry(2.8, 0.4, 1.6),
      new THREE.MeshStandardMaterial({ color: 0xffeb3b })
    );
    hoverBus.position.y = 0.1;
    busGroup.add(hoverBus);
    const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const stripeGeometry = new THREE.PlaneGeometry(2.2, 0.12);
    [-0.15, 0.15].forEach((y) => {
      const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
      stripe.position.set(0, y, 0.81);
      busGroup.add(stripe);
    });

    const evaTexture = new THREE.TextureLoader().load("eva.png");
    const evaSprite = new THREE.Sprite(
      new THREE.SpriteMaterial({ map: evaTexture, transparent: true })
    );
    evaSprite.scale.set(4, 4, 4);
    evaSprite.position.set(0, 1.1, 0);
    busGroup.add(evaSprite);

    const wand = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04, 0.04, 0.6, 8),
      new THREE.MeshStandardMaterial({ color: 0xfdf6ff })
    );
    wand.position.set(0.45, 1.1, 0.2);
    wand.rotation.z = Math.PI / 4;
    busGroup.add(wand);
    const wandTip = new THREE.Mesh(
      new THREE.SphereGeometry(0.09, 12, 12),
      new THREE.MeshStandardMaterial({ color: 0xfff3a1, emissive: 0xfff3a1 })
    );
    wandTip.position.set(0.65, 1.35, 0.35);
    busGroup.add(wandTip);

    busGroup.position.set(0, -0.2, 3.5);
    scene.add(busGroup);

    const cloudTexture = (() => {
      const cloudCanvas = document.createElement("canvas");
      cloudCanvas.width = 256;
      cloudCanvas.height = 128;
      const ctx = cloudCanvas.getContext("2d");
      ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
      ctx.beginPath();
      ctx.ellipse(70, 70, 55, 35, 0, 0, Math.PI * 2);
      ctx.ellipse(120, 55, 65, 45, 0, 0, Math.PI * 2);
      ctx.ellipse(170, 70, 50, 32, 0, 0, Math.PI * 2);
      ctx.fill();
      return new THREE.CanvasTexture(cloudCanvas);
    })();

    const clouds = [];
    const cloudCount = 18;
    for (let i = 0; i < cloudCount; i++) {
      const cloud = new THREE.Sprite(
        new THREE.SpriteMaterial({ map: cloudTexture, transparent: true, opacity: 0.85 })
      );
      cloud.scale.set(6 + Math.random() * 6, 3 + Math.random() * 3, 1);
      cloud.position.set(
        (Math.random() - 0.5) * 20,
        2 + Math.random() * 6,
        -10 - Math.random() * 60
      );
      cloud.userData = { speedFactor: 0.4 + Math.random() * 0.6 };
      clouds.push(cloud);
      scene.add(cloud);
    }

    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const numbers = Array.from({ length: 20 }, (_, i) => String(i + 1));
    const bubbleLabels = [...letters, ...numbers];

    function makeTextSprite(text) {
      const size = 256;
      const textCanvas = document.createElement("canvas");
      textCanvas.width = size;
      textCanvas.height = size;
      const ctx = textCanvas.getContext("2d");
      ctx.fillStyle = "rgba(255, 255, 255, 0.0)";
      ctx.fillRect(0, 0, size, size);
      ctx.font = "bold 120px Comic Sans MS";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#6b4fc7";
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 10;
      ctx.strokeText(text, size / 2, size / 2 + 4);
      ctx.fillText(text, size / 2, size / 2 + 4);

      const texture = new THREE.CanvasTexture(textCanvas);
      texture.minFilter = THREE.LinearFilter;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(1.2, 1.2, 1.2);
      return sprite;
    }

    const bubbles = [];
    const poppingBubbles = new Set();
    const bubbleCount = 18;
    const bubbleGeometry = new THREE.SphereGeometry(0.45, 20, 20);
    const bubbleMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.55,
      roughness: 0.2,
      metalness: 0.1
    });

    function spawnBubble(existingBubble) {
      const label = bubbleLabels[Math.floor(Math.random() * bubbleLabels.length)];
      const bubble = existingBubble || new THREE.Mesh(bubbleGeometry, bubbleMaterial.clone());
      bubble.material.color.setHSL(Math.random(), 0.4, 0.85);
      bubble.material.opacity = 0.55;
      bubble.scale.setScalar(1);
      bubble.position.set(
        (Math.random() - 0.5) * 10,
        1 + Math.random() * 4,
        -10 - Math.random() * 40
      );
      bubble.userData = {
        label,
        floatOffset: Math.random() * Math.PI * 2,
        sprite: bubble.userData ? bubble.userData.sprite : null,
        popProgress: 0
      };
      if (bubble.userData.sprite) {
        bubble.remove(bubble.userData.sprite);
      }
      const sprite = makeTextSprite(label);
      sprite.position.set(0, 0, 0.6);
      bubble.add(sprite);
      bubble.userData.sprite = sprite;
      if (!existingBubble) {
        scene.add(bubble);
        bubbles.push(bubble);
      }
    }

    for (let i = 0; i < bubbleCount; i++) {
      spawnBubble();
    }

    const sparkles = [];
    const magicBursts = [];
    function addSparkles(screenX, screenY) {
      for (let i = 0; i < 18; i++) {
        sparkles.push({
          x: screenX,
          y: screenY,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.7) * 3,
          life: 1
        });
      }
    }

    function showLetter(label) {
      letterPopup.textContent = label;
      letterPopup.style.opacity = "1";
      clearTimeout(showLetter._timeout);
      showLetter._timeout = setTimeout(() => {
        letterPopup.style.opacity = "0";
      }, 900);
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const targetSequence = ["E", "V", "A"];
    let sequenceIndex = 0;
    let easterEggTriggered = false;

    const loopAudio = new Audio("loop.mp3");
    loopAudio.loop = true;
    const evaThemeAudio = new Audio("eva_theme.mp3");
    const popAudio = new Audio("pop.mp3");
    const magicAudio = new Audio("magic.mp3");

    let isGameStarted = false;

    function enterFullscreen() {
      if (document.fullscreenElement) {
        return Promise.resolve();
      }
      if (document.documentElement.requestFullscreen) {
        return document.documentElement.requestFullscreen();
      }
      return Promise.resolve();
    }

    function startGame() {
      if (isGameStarted) {
        return;
      }
      isGameStarted = true;
      splashScreen.style.display = "none";
      enterFullscreen();
      loopAudio.currentTime = 0;
      loopAudio.play().catch(() => {});
    }

    startButton.addEventListener("click", startGame);

    function handleTap(event) {
      if (!isGameStarted) {
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      pointer.x = x * 2 - 1;
      pointer.y = -(y * 2 - 1);

      raycaster.setFromCamera(pointer, camera);

      let closestBubble = null;
      let closestDistance = Infinity;
      bubbles.forEach((bubble) => {
        if (bubble.userData.popProgress > 0) {
          return;
        }
        const distanceToRay = raycaster.ray.distanceToPoint(bubble.position);
        if (distanceToRay < 1.4) {
          const camDistance = bubble.position.distanceTo(camera.position);
          if (camDistance < closestDistance) {
            closestDistance = camDistance;
            closestBubble = bubble;
          }
        }
      });

      if (closestBubble) {
        const label = closestBubble.userData.label;
        const vector = closestBubble.position.clone().project(camera);
        const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const screenY = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        addSparkles(screenX, screenY);
        showLetter(label);
        popAudio.currentTime = 0;
        popAudio.play().catch(() => {});
        closestBubble.userData.popProgress = 0.01;
        poppingBubbles.add(closestBubble);
        magicBursts.push({
          start: performance.now(),
          x: screenX,
          y: screenY
        });
        magicAudio.currentTime = 0;
        magicAudio.play().catch(() => {});

        if (!easterEggTriggered) {
          if (label === targetSequence[sequenceIndex]) {
            sequenceIndex += 1;
            if (sequenceIndex === targetSequence.length) {
              easterEggTriggered = true;
              loopAudio.pause();
              evaThemeAudio.currentTime = 0;
              evaThemeAudio.play().catch(() => {});
            }
          } else if (label === targetSequence[0]) {
            sequenceIndex = 1;
          } else {
            sequenceIndex = 0;
          }
        }
      }
    }

    window.addEventListener("pointerdown", (event) => {
      handleTap(event);
    });

    function resize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      uiCanvas.width = window.innerWidth;
      uiCanvas.height = window.innerHeight;
      hudCanvas.width = window.innerWidth;
      hudCanvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    let lastTime = 0;
    const speed = 0.04;

    function animate(time) {
      requestAnimationFrame(animate);
      const delta = (time - lastTime) / 16.666;
      lastTime = time;

      if (!isGameStarted) {
        renderer.render(scene, camera);
        return;
      }

      clouds.forEach((cloud) => {
        cloud.position.z += speed * 10 * cloud.userData.speedFactor * delta;
        if (cloud.position.z > camera.position.z + 2) {
          cloud.position.z = -70 - Math.random() * 40;
          cloud.position.x = (Math.random() - 0.5) * 20;
          cloud.position.y = 2 + Math.random() * 6;
          cloud.scale.set(6 + Math.random() * 6, 3 + Math.random() * 3, 1);
        }
      });

      bubbles.forEach((bubble) => {
        if (bubble.userData.popProgress <= 0) {
          bubble.position.z += speed * 1.2 * delta;
        }
        bubble.position.y += Math.sin(time * 0.002 + bubble.userData.floatOffset) * 0.005;
        if (bubble.position.z > camera.position.z + 1) {
          spawnBubble(bubble);
        }
      });

      poppingBubbles.forEach((bubble) => {
        bubble.userData.popProgress += 0.08;
        const scale = Math.max(0, 1 - bubble.userData.popProgress);
        bubble.scale.setScalar(scale);
        bubble.material.opacity = Math.max(0, 0.55 * scale);
        if (bubble.userData.popProgress >= 1) {
          poppingBubbles.delete(bubble);
          spawnBubble(bubble);
        }
      });

      const hoverOffset = Math.sin(time * 0.003) * 0.08;
      busGroup.position.y = -0.1 + hoverOffset;
      wandTip.scale.setScalar(1 + Math.sin(time * 0.01) * 0.1);
      const cameraTarget = new THREE.Vector3(0, 1.6 + hoverOffset, 5.5);
      camera.position.lerp(cameraTarget, 0.06);
      camera.lookAt(0, 1, 0);

      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
      sparkles.forEach((sparkle) => {
        sparkle.x += sparkle.vx;
        sparkle.y += sparkle.vy;
        sparkle.life -= 0.03;
      });
      for (let i = sparkles.length - 1; i >= 0; i--) {
        if (sparkles[i].life <= 0) {
          sparkles.splice(i, 1);
        }
      }
      sparkles.forEach((sparkle) => {
        uiCtx.beginPath();
        uiCtx.fillStyle = `rgba(255, 215, 130, ${sparkle.life})`;
        uiCtx.arc(sparkle.x, sparkle.y, 4, 0, Math.PI * 2);
        uiCtx.fill();
      });

      hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
      const now = performance.now();
      const wandWorld = new THREE.Vector3();
      wandTip.getWorldPosition(wandWorld);
      const wandScreen = wandWorld.clone().project(camera);
      const wandScreenX = (wandScreen.x * 0.5 + 0.5) * window.innerWidth;
      const wandScreenY = (-wandScreen.y * 0.5 + 0.5) * window.innerHeight;
      for (let i = magicBursts.length - 1; i >= 0; i--) {
        const burst = magicBursts[i];
        const age = (now - burst.start) / 450;
        if (age > 1) {
          magicBursts.splice(i, 1);
          continue;
        }
        const alpha = 1 - age;
        hudCtx.strokeStyle = `rgba(255, 221, 122, ${alpha})`;
        hudCtx.lineWidth = 4;
        hudCtx.beginPath();
        hudCtx.moveTo(wandScreenX, wandScreenY);
        hudCtx.lineTo(burst.x, burst.y);
        hudCtx.stroke();
        hudCtx.fillStyle = `rgba(255, 182, 233, ${alpha})`;
        hudCtx.beginPath();
        hudCtx.arc(burst.x, burst.y, 12 + age * 8, 0, Math.PI * 2);
        hudCtx.fill();
      }
      hudCtx.beginPath();
      hudCtx.strokeStyle = "rgba(255,255,255,0.7)";
      hudCtx.lineWidth = 3;
      hudCtx.arc(window.innerWidth / 2, window.innerHeight / 2, 20, 0, Math.PI * 2);
      hudCtx.stroke();

      renderer.render(scene, camera);
    }

    animate(0);
  </script>
</body>
</html>
